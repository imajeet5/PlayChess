[{"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\index.tsx":"1","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\App.tsx":"2","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\connection\\socket.ts":"3","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\pages\\WelcomePage.tsx":"4","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\pages\\HomePage.tsx":"5","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\contexts\\SocketContext.tsx":"6","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\InputForm.tsx":"7","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\JoinRoom.tsx":"8","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\UserWaiting.tsx":"9","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\Lobby.tsx":"10","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\model\\chess.js":"11","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\model\\square.js":"12","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\model\\chesspiece.js":"13","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\ui\\chessgame.tsx":"14","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\ui\\piecemap.tsx":"15","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\ui\\piece.tsx":"16"},{"size":256,"mtime":1608279263510,"results":"17","hashOfConfig":"18"},{"size":767,"mtime":1608303648825,"results":"19","hashOfConfig":"18"},{"size":552,"mtime":1608302864167,"results":"20","hashOfConfig":"18"},{"size":1713,"mtime":1608380396136,"results":"21","hashOfConfig":"18"},{"size":1703,"mtime":1608364628107,"results":"22","hashOfConfig":"18"},{"size":1030,"mtime":1608364184114,"results":"23","hashOfConfig":"18"},{"size":1090,"mtime":1608375882285,"results":"24","hashOfConfig":"18"},{"size":2055,"mtime":1608393085683,"results":"25","hashOfConfig":"18"},{"size":2680,"mtime":1608392647428,"results":"26","hashOfConfig":"18"},{"size":915,"mtime":1608390392484,"results":"27","hashOfConfig":"18"},{"size":10556,"mtime":1608379587509,"results":"28","hashOfConfig":"18"},{"size":1785,"mtime":1608379587520,"results":"29","hashOfConfig":"18"},{"size":1094,"mtime":1608379587516,"results":"30","hashOfConfig":"18"},{"size":8265,"mtime":1608390169598,"results":"31","hashOfConfig":"18"},{"size":1050,"mtime":1608390292747,"results":"32","hashOfConfig":"18"},{"size":1256,"mtime":1608390202736,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"1dt7vwq",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"36"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"36"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"57","messages":"58","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"60"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"60"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"60"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\index.tsx",[],["73","74"],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\App.tsx",[],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\connection\\socket.ts",[],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\pages\\WelcomePage.tsx",["75"],"import React, { useContext, useEffect, useState } from 'react';\r\nimport { useParams } from 'react-router-dom';\r\nimport { SocketContext } from '../../contexts/SocketContext';\r\nimport JoinRoom from '../ui-shared/JoinRoom';\r\nimport UserWaiting from '../ui-shared/UserWaiting';\r\nimport Lobby from '../ui-shared/Lobby';\r\n\r\n// Either it a new user waiting to join the existing game or new user (creator) waiting for opponent\r\nexport default function WelcomePage() {\r\n  const { socket, socketId, username } = useContext(SocketContext);\r\n  const { gameId } = useParams<{ gameId: string }>();\r\n  // if socketId exist then user is the creator of the game\r\n  const [isCreator] = useState(socketId ? true : false);\r\n  const [opponentUserName, setOpponentUserName] = useState(null);\r\n\r\n  const userWaiting = (\r\n    <React.Fragment>\r\n      <UserWaiting\r\n        socket={socket}\r\n        username={username}\r\n        setOpponentUserName={setOpponentUserName}\r\n        gameId={gameId}\r\n      />\r\n    </React.Fragment>\r\n  );\r\n  const userWantToJoin = (\r\n    <React.Fragment>\r\n      <JoinRoom\r\n        gameId={gameId}\r\n        isCreator={false}\r\n        setOpponentUserName={setOpponentUserName}\r\n      />\r\n    </React.Fragment>\r\n  );\r\n\r\n  const waitingJSX = isCreator ? userWaiting : userWantToJoin;\r\n\r\n  // if we got the opponent User name we will start the game, otherwise we will wait to get the opponent username\r\n  return (\r\n    <div>\r\n      {opponentUserName ? (\r\n        <Lobby\r\n          myUserName={username}\r\n          opponentUserName={opponentUserName}\r\n          isCreator={isCreator}\r\n          socket={socket} \r\n          gameId={gameId}\r\n        />\r\n      ) : (\r\n        waitingJSX\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\pages\\HomePage.tsx",["76","77"],"import React, { useContext, useEffect, useRef, useState } from 'react';\r\nimport { useHistory } from 'react-router-dom';\r\nimport { SocketContext } from '../../contexts/SocketContext';\r\nimport InputForm from '../ui-shared/InputForm';\r\nimport uuid from 'uuid/dist/v4';\r\n\r\nexport default function HomePage() {\r\n  const { socket, socketId, username, setUsername } = useContext(SocketContext);\r\n  const [isFormSubmitted, setIsFormSubmitted] = useState(false);\r\n  // const [username, setUsername] = useState('');\r\n  const history = useHistory();\r\n\r\n  // when game is created we will send the user to /game/:gameId route to wait for other user to connect\r\n  useEffect(() => {\r\n    socket.on('gameCreated', (data: { gameId: string; socketId: string }) => {\r\n      history.push(`/game/${data.gameId}`);\r\n    });\r\n\r\n    // when the component un-mount we will stop listening to the event\r\n    return () => {\r\n      socket.off('gameCreated');\r\n    };\r\n  }, []);\r\n\r\n  // we will connect to the socket when the user submit the form\r\n  const handleSubmit = (e, value) => {\r\n    e.preventDefault();\r\n    if (socket.connected) {\r\n      socket.close();\r\n    }\r\n    socket.open();\r\n    setUsername(value);\r\n    setIsFormSubmitted(true);\r\n  };\r\n\r\n  // then when the socket id is available we and the form is submitted\r\n  useEffect(() => {\r\n    if (socketId && isFormSubmitted) {\r\n      const newGameRoomId = uuid();\r\n      socket.emit('createNewGame', newGameRoomId);\r\n\r\n      setIsFormSubmitted(false);\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [socketId, isFormSubmitted]);\r\n\r\n  return (\r\n    <div>\r\n      <InputForm username={username} handleSubmit={handleSubmit} />\r\n    </div>\r\n  );\r\n}\r\n","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\contexts\\SocketContext.tsx",[],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\InputForm.tsx",[],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\JoinRoom.tsx",["78","79"],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\UserWaiting.tsx",["80","81","82"],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\ui-shared\\Lobby.tsx",["83"],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\model\\chess.js",["84","85","86"],"import Chess from 'chess.js'\nimport ChessPiece from './chesspiece'\nimport Square from './square'\n// when indexing, remember: [y][x]. \n/**\n * If the player color is black, make sure to invert the board.\n */\n\n\n\n\nclass Game {\n    constructor(thisPlayersColorIsWhite) {\n        this.thisPlayersColorIsWhite = thisPlayersColorIsWhite // once initialized, this value should never change.\n        // console.log(\"this player's color is white: \" + this.thisPlayersColorIsWhite) \n        this.chessBoard = this.makeStartingBoard() // the actual chessBoard\n        this.chess = new Chess()\n\n        this.toCoord = thisPlayersColorIsWhite ? {\n            0:8, 1:7, 2: 6, 3: 5, 4: 4, 5: 3, 6: 2, 7: 1\n        } : {\n            0:1, 1:2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8\n        }\n        \n        this.toAlphabet = thisPlayersColorIsWhite ? {\n            0:\"a\", 1:\"b\", 2: \"c\", 3: \"d\", 4: \"e\", 5: \"f\", 6: \"g\", 7: \"h\"\n        } : {\n            0:\"h\", 1:\"g\", 2: \"f\", 3: \"e\", 4: \"d\", 5: \"c\", 6: \"b\", 7: \"a\"\n        }\n\n        this.toCoord2 = thisPlayersColorIsWhite ? {\n            8:0, 7:1, 6: 2, 5: 3, 4: 4, 3: 5, 2: 6, 1: 7\n        } : {\n            1:0, 2:1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 7\n        }\n        \n        this.toAlphabet2 = thisPlayersColorIsWhite ? {\n            \"a\":0, \"b\":1, \"c\":2, \"d\":3, \"e\":4, \"f\":5, \"g\":6, \"h\":7\n        } : {\n            \"h\":0, \"g\":1, \"f\":2, \"e\":3, \"d\":4, \"c\":5, \"b\":6, \"a\":7\n        }\n\n        this.nQueens = 1\n    }\n\n    getBoard() {\n        return this.chessBoard\n    }\n\n    // nextPlayersTurn() {\n    //     this.isWhitesTurn = !this.isWhitesTurn\n    // }\n\n    setBoard(newBoard) {\n        this.chessBoard = newBoard\n    }\n\n    movePiece(pieceId, to, isMyMove) {\n\n        const to2D = isMyMove ? {\n            105:0, 195:1, 285: 2, 375: 3, 465: 4, 555: 5, 645: 6, 735: 7\n        } : {\n            105:7, 195:6, 285: 5, 375: 4, 465: 3, 555: 2, 645: 1, 735: 0\n        }\n\n\n        var currentBoard = this.getBoard()\n        const pieceCoordinates = this.findPiece(currentBoard, pieceId)\n        \n        \n        // can't find piece coordinates (piece doesn't exist on the board)\n        if (!pieceCoordinates) {\n            return\n        }\n\n        const y = pieceCoordinates[1]\n        const x = pieceCoordinates[0]\n\n        // new coordinates\n        const to_y = to2D[to[1]]\n        const to_x = to2D[to[0]]\n\n        const originalPiece = currentBoard[y][x].getPiece()\n    \n        if (y === to_y && x === to_x) {\n            return \"moved in the same position.\"\n        }\n\n        /**\n         * In order for this method to do anything meaningful, \n         * the 'reassign const' line of code must run. Therefore, \n         * for it to run, we must check first that the given move is valid. \n         */\n\n        const isPromotion = this.isPawnPromotion(to, pieceId[1])\n        const moveAttempt = !isPromotion ? this.chess.move({\n                from: this.toChessMove([x, y], to2D),\n                to: this.toChessMove(to, to2D),\n                piece: pieceId[1]}) \n            : \n            this.chess.move({\n                from: this.toChessMove([x, y], to2D),\n                to: this.toChessMove(to, to2D),\n                piece: pieceId[1],\n                promotion: 'q'\n            })\n\n\n         console.log(moveAttempt)\n        // console.log(isPromotion)\n\n        if (moveAttempt === null) {\n            return \"invalid move\"\n        }\n\n\n        if (moveAttempt.flags === 'e') {\n            const move = moveAttempt.to \n            const x = this.toAlphabet2[move[0]]\n            let y\n            if (moveAttempt.color === 'w') {\n                y = parseInt(move[1], 10) - 1\n            } else {\n                y = parseInt(move[1], 10) + 1 \n            }\n            currentBoard[this.toCoord2[y]][x].setPiece(null)\n        }\n\n\n\n        // Check castling\n        const castle = this.isCastle(moveAttempt)\n        if (castle.didCastle) {\n            /**\n             *  The main thing we are doing here is moving the right rook\n             *  to the right position. \n             * \n             * - Get original piece by calling getPiece() on the original [x, y]\n             * - Set the new [to_x, to_y] to the original piece\n             * - Set the original [x, y] to null\n             */\n\n            const originalRook = currentBoard[castle.y][castle.x].getPiece()\n            currentBoard[castle.to_y][castle.to_x].setPiece(originalRook)\n            currentBoard[castle.y][castle.x].setPiece(null)\n        }\n\n\n        // ___actually changing the board model___\n\n        const reassign = isPromotion ? currentBoard[to_y][to_x].setPiece(\n            new ChessPiece(\n                'queen', \n                false, \n                pieceId[0] === 'w' ? 'white' : 'black', \n                pieceId[0] === 'w' ? 'wq' + this.nQueens : 'bq' + this.nQueens))\n            : currentBoard[to_y][to_x].setPiece(originalPiece)\n\n        if (reassign !== \"user tried to capture their own piece\") {\n            currentBoard[y][x].setPiece(null)\n        } else {\n            return reassign\n        }\n\n        // ___actually changing the board model___\n\n\n        const checkMate = this.chess.in_checkmate() ? \" has been checkmated\" : \" has not been checkmated\"\n        console.log(this.chess.turn() + checkMate)\n        if (checkMate === \" has been checkmated\") {\n            return this.chess.turn() + checkMate\n        }\n        // changes the fill color of the opponent's king that is in check\n        const check = this.chess.in_check() ? \" is in check\" : \" is not in check\"\n        console.log(this.chess.turn() + check)\n        if (check === \" is in check\") {\n            return this.chess.turn() + check\n        }\n\n        console.log(currentBoard)\n        // update board\n        this.setBoard(currentBoard)\n    }\n\n\n\n    isCastle(moveAttempt) {\n        /**\n         * Assume moveAttempt is legal. \n         * \n         * {moveAttempt} -> {boolean x, y to_x, to_y} \n         * \n         * returns if a player has castled, the final position of \n         * the rook (to_x, to_y), and the original position of the rook (x, y)\n         * \n         */\n\n\n        const piece = moveAttempt.piece\n        const move = {from: moveAttempt.from, to: moveAttempt.to}\n\n        const isBlackCastle = ((move.from === 'e1' && move.to === 'g1') || (move.from === 'e1' && move.to === 'c1')) \n        const isWhiteCastle = (move.from === 'e8' && move.to === 'g8') || (move.from === 'e8' && move.to === 'c8')\n        \n\n        if (!(isWhiteCastle || isBlackCastle) || piece !== 'k') {\n            return {\n                didCastle: false\n            }\n        }\n\n        let originalPositionOfRook\n        let newPositionOfRook\n\n        if ((move.from === 'e1' && move.to === 'g1')) {\n            originalPositionOfRook = 'h1'\n            newPositionOfRook = 'f1'\n        } else if ((move.from === 'e1' && move.to === 'c1')) {\n            originalPositionOfRook = 'a1'\n            newPositionOfRook = 'd1'\n        } else if ((move.from === 'e8' && move.to === 'g8')) {\n            originalPositionOfRook = 'h8'\n            newPositionOfRook = 'f8'\n        } else { // e8 to c8\n            originalPositionOfRook = 'a8'\n            newPositionOfRook = 'd8'\n        }   \n\n    \n        return {\n            didCastle: true, \n            x: this.toAlphabet2[originalPositionOfRook[0]], \n            y: this.toCoord2[originalPositionOfRook[1]], \n            to_x: this.toAlphabet2[newPositionOfRook[0]], \n            to_y: this.toCoord2[newPositionOfRook[1]]\n        }\n    }\n\n\n    isPawnPromotion(to, piece) {\n        const res = piece === 'p' && (to[1] === 105 || to[1] === 735)\n        if (res) {\n            this.nQueens += 1\n        }\n        return res\n    }\n\n\n    toChessMove(finalPosition, to2D) {\n      \n        let move \n\n        if (finalPosition[0] > 100) {\n            move = this.toAlphabet[to2D[finalPosition[0]]] + this.toCoord[to2D[finalPosition[1]]]\n        } else {\n            move = this.toAlphabet[finalPosition[0]] + this.toCoord[finalPosition[1]]\n        }\n       \n       //  console.log(\"proposed move: \" + move)\n        return move\n    }\n\n    findPiece(board, pieceId) {\n        // ChessBoard, String -> [Int, Int]\n      //  console.log(\"piecetofind: \" + pieceId)\n        for (var i = 0; i < 8; i++) {\n            for (var j = 0; j < 8; j++) {\n                if (board[i][j].getPieceIdOnThisSquare() === pieceId) {\n                    return [j, i]\n                }\n            }\n        }\n    }\n\n    makeStartingBoard() {\n        const backRank = [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"]\n        var startingChessBoard = []\n        for (var i = 0; i < 8; i++) {\n            startingChessBoard.push([])\n            for (var j = 0; j < 8; j++) {\n                // j is horizontal\n                // i is vertical\n                const coordinatesOnCanvas = [((j + 1) * 90 + 15), ((i + 1) * 90 + 15)]\n                const emptySquare = new Square(j, i, null, coordinatesOnCanvas)\n                \n                startingChessBoard[i].push(emptySquare)\n            }\n        }\n        const whiteBackRankId = [\"wr1\", \"wn1\", \"wb1\", \"wq1\", \"wk1\", \"wb2\", \"wn2\", \"wr2\"]\n        const blackBackRankId = [\"br1\", \"bn1\", \"bb1\", \"bq1\", \"bk1\", \"bb2\", \"bn2\", \"br2\"]\n        for (var j = 0; j < 8; j += 7) {\n            for (var i = 0; i < 8; i++) {\n                if (j == 0) {\n                    // top\n                    // console.log(backRank[i])\n                    startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? blackBackRankId[i] : whiteBackRankId[i]))\n                    startingChessBoard[j + 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"black\" : \"white\", this.thisPlayersColorIsWhite ? \"bp\" + i : \"wp\" + i))\n                } else {\n                    // bottom\n                    startingChessBoard[j - 1][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(\"pawn\", false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? \"wp\" + i : \"bp\" + i))\n                    startingChessBoard[j][this.thisPlayersColorIsWhite ? i : 7 - i].setPiece(new ChessPiece(backRank[i], false, this.thisPlayersColorIsWhite ? \"white\" : \"black\", this.thisPlayersColorIsWhite ? whiteBackRankId[i] : blackBackRankId[i]))\n                }\n            }\n        }\n        return startingChessBoard\n    }\n}\n\nexport default Game",["87","88"],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\model\\square.js",["89","90"],"class Square {\n    constructor(x, y, pieceOnThisSquare, canvasCoord) {\n        this.x = x // Int 0 < x < 7\n        this.y = y // Int 0 < y < 7 \n        this.canvasCoord = canvasCoord\n        this.pieceOnThisSquare = pieceOnThisSquare // ChessPiece || null\n    }\n\n    setPiece(newPiece) {\n        if (newPiece === null && this.pieceOnThisSquare === null) {\n            return\n        } else if (newPiece === null) {\n            // case where the function caller wants to remove the piece that is on this square. \n            this.pieceOnThisSquare.setSquare(undefined)\n            this.pieceOnThisSquare = null\n        } else if (this.pieceOnThisSquare === null) {\n            // case where the function caller wants assign a new piece on this square\n            this.pieceOnThisSquare = newPiece\n            newPiece.setSquare(this)\n        } else if (this.getPieceIdOnThisSquare() != newPiece.id && this.pieceOnThisSquare.color != newPiece.color) {\n            // case where the function caller wants to change the piece on this square. (only different color allowed)\n            console.log(\"capture!\")\n            this.pieceOnThisSquare = newPiece\n            newPiece.setSquare(this)\n        } else {\n            return \"user tried to capture their own piece\"\n        }\n    }\n\n    removePiece() {\n        this.pieceOnThisSquare = null\n    }\n\n    getPiece() {\n        return this.pieceOnThisSquare \n    }\n\n    getPieceIdOnThisSquare() {\n        if (this.pieceOnThisSquare === null) {\n            return \"empty\"\n        }\n        return this.pieceOnThisSquare.id\n    }\n\n    isOccupied() {\n        return this.pieceOnThisSquare != null\n    }\n\n    getCoord() {\n        return [this.x, this.y]\n    }\n\n    getCanvasCoord() {\n        return this.canvasCoord\n    }\n}\n\nexport default Square","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\model\\chesspiece.js",["91","92"],"\nclass ChessPiece {\n    constructor(name, isAttacked, color, id) {\n        this.name = name // string\n        this.isAttacked = isAttacked // boolean\n        this.color = color // string\n        this.id = id // string\n    }\n\n    setSquare(newSquare) {\n        // set the square this piece is sitting top of. \n        // on any given piece (on the board), there will always be a piece on top of it. \n        // console.log(newSquare)\n        if (newSquare === undefined) {\n            this.squareThisPieceIsOn = newSquare\n            return \n        }\n\n        if (this.squareThisPieceIsOn === undefined) {\n            this.squareThisPieceIsOn = newSquare\n            newSquare.setPiece(this)\n        }\n\n        const isNewSquareDifferent = this.squareThisPieceIsOn.x != newSquare.x || this.squareThisPieceIsOn.y != newSquare.y\n\n        if (isNewSquareDifferent) {\n            // console.log(\"set\")\n            this.squareThisPieceIsOn = newSquare\n            newSquare.setPiece(this)\n        }\n    }\n\n    getSquare() {\n        return this.squareThisPieceIsOn\n    }\n}\n\n\nexport default ChessPiece","D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\ui\\chessgame.tsx",[],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\ui\\piecemap.tsx",[],"D:\\OpenSourceLearningProjects\\chessGame-remake\\frontend\\src\\components\\chess\\ui\\piece.tsx",[],{"ruleId":"93","replacedBy":"94"},{"ruleId":"95","replacedBy":"96"},{"ruleId":"97","severity":1,"message":"98","line":1,"column":29,"nodeType":"99","messageId":"100","endLine":1,"endColumn":38},{"ruleId":"97","severity":1,"message":"101","line":1,"column":40,"nodeType":"99","messageId":"100","endLine":1,"endColumn":46},{"ruleId":"102","severity":1,"message":"103","line":23,"column":6,"nodeType":"104","endLine":23,"endColumn":8,"suggestions":"105"},{"ruleId":"102","severity":1,"message":"106","line":36,"column":6,"nodeType":"104","endLine":36,"endColumn":8,"suggestions":"107"},{"ruleId":"102","severity":1,"message":"108","line":45,"column":6,"nodeType":"104","endLine":45,"endColumn":13,"suggestions":"109"},{"ruleId":"97","severity":1,"message":"110","line":1,"column":17,"nodeType":"99","messageId":"100","endLine":1,"endColumn":39},{"ruleId":"97","severity":1,"message":"111","line":2,"column":19,"nodeType":"99","messageId":"100","endLine":2,"endColumn":26},{"ruleId":"102","severity":1,"message":"112","line":38,"column":6,"nodeType":"104","endLine":38,"endColumn":8,"suggestions":"113"},{"ruleId":"97","severity":1,"message":"98","line":1,"column":17,"nodeType":"99","messageId":"100","endLine":1,"endColumn":26},{"ruleId":"114","severity":1,"message":"115","line":291,"column":18,"nodeType":"99","messageId":"116","endLine":291,"endColumn":19},{"ruleId":"114","severity":1,"message":"117","line":292,"column":22,"nodeType":"99","messageId":"116","endLine":292,"endColumn":23},{"ruleId":"118","severity":1,"message":"119","line":293,"column":23,"nodeType":"120","messageId":"121","endLine":293,"endColumn":25},{"ruleId":"93","replacedBy":"94"},{"ruleId":"95","replacedBy":"96"},{"ruleId":"118","severity":1,"message":"122","line":20,"column":50,"nodeType":"120","messageId":"121","endLine":20,"endColumn":52},{"ruleId":"118","severity":1,"message":"122","line":20,"column":97,"nodeType":"120","messageId":"121","endLine":20,"endColumn":99},{"ruleId":"118","severity":1,"message":"122","line":24,"column":65,"nodeType":"120","messageId":"121","endLine":24,"endColumn":67},{"ruleId":"118","severity":1,"message":"122","line":24,"column":110,"nodeType":"120","messageId":"121","endLine":24,"endColumn":112},"no-native-reassign",["123"],"no-negated-in-lhs",["124"],"@typescript-eslint/no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useRef' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'history' and 'socket'. Either include them or remove the dependency array.","ArrayExpression",["125"],"React Hook useEffect has missing dependencies: 'setOpponentUserName' and 'socket'. Either include them or remove the dependency array. If 'setOpponentUserName' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["126"],"React Hook useEffect has a missing dependency: 'history'. Either include it or remove the dependency array.",["127"],"'TextareaHTMLAttributes' is defined but never used.","'Message' is defined but never used.","React Hook useEffect has missing dependencies: 'gameId', 'setOpponentUserName', 'socket', and 'username'. Either include them or remove the dependency array. If 'setOpponentUserName' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["128"],"no-redeclare","'j' is already defined.","redeclared","'i' is already defined.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-global-assign","no-unsafe-negation",{"desc":"129","fix":"130"},{"desc":"131","fix":"132"},{"desc":"133","fix":"134"},{"desc":"135","fix":"136"},"Update the dependencies array to be: [history, socket]",{"range":"137","text":"138"},"Update the dependencies array to be: [setOpponentUserName, socket]",{"range":"139","text":"140"},"Update the dependencies array to be: [error, history]",{"range":"141","text":"142"},"Update the dependencies array to be: [gameId, setOpponentUserName, socket, username]",{"range":"143","text":"144"},[944,946],"[history, socket]",[1170,1172],"[setOpponentUserName, socket]",[1323,1330],"[error, history]",[1087,1089],"[gameId, setOpponentUserName, socket, username]"]